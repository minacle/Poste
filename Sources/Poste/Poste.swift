// This file is automatically generated by GYB: Generate Your Boilerplate
// DO NOT EDIT

import Dispatch

internal let globalQueue =
    DispatchQueue(
        label: "moe.minacle.lib.poste",
        attributes: .concurrent)

public class Poste<T> {

    internal let group = DispatchGroup()
    internal let qos: DispatchQoS

    internal private(set) var result: T!

    private var mainWorkItem: DispatchWorkItem!
    private var timeoutWorkItem: DispatchWorkItem!

    private var done = false
    private var cancelled = false

    internal private(set) var isFired = false

    internal required init(closure: @escaping () -> T, qos: DispatchQoS, timeout: DispatchTimeInterval) {
        self.group.enter()
        self.qos = qos
        self.mainWorkItem = DispatchWorkItem(qos: self.qos) {
            self.result = closure()
        }
        self.timeoutWorkItem = DispatchWorkItem(qos: self.qos) {
            if let time = DispatchTime(dispatchTimeIntervalSinceNow: timeout) {
                switch self.mainWorkItem.wait(timeout: time) {
                case .success:
                    self.done = true
                case .timedOut:
                    self.mainWorkItem.cancel()
                    self.cancelled = true
                }
            }
            else {
                self.mainWorkItem.wait()
                self.done = true
            }
        }
        self.timeoutWorkItem.notify(qos: self.qos, queue: globalQueue) {
            self.group.leave()
        }
        self.fire()
    }

    internal func fire() {
        guard !self.isFired else {
            return
        }
        self.isFired = true
        globalQueue.async(group: self.group, execute: self.mainWorkItem)
        globalQueue.async(group: self.group, execute: self.timeoutWorkItem)
    }

    public func done(_ closure: @escaping (T) -> Void) -> Self {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.done else {
                return
            }
            closure(self.result)
        }
        return self
    }

    public func cancelled(_ closure: @escaping () -> Void) -> Self {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.cancelled else {
                return
            }
            closure()
        }
        return self
    }

    public func then<U>(_ lazy: LazyPoste<U>) -> Poste<U> {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.done else {
                return
            }
            lazy.fire()
        }
        return lazy
    }

    public func `else`<U>(_ lazy: LazyPoste<U>) -> Poste<U> {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard !self.done else {
                return
            }
            lazy.fire()
        }
        return lazy
    }

    public func then<U>(_ lazy: LazyThrowingPoste<U>) -> ThrowingPoste<U> {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.done else {
                return
            }
            lazy.fire()
        }
        return lazy
    }

    public func `else`<U>(_ lazy: LazyThrowingPoste<U>) -> ThrowingPoste<U> {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard !self.done else {
                return
            }
            lazy.fire()
        }
        return lazy
    }
}

extension Poste
where T == Void {

    @discardableResult
    public func done(_ closure: @escaping (T) -> Void) -> Self {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.done else {
                return
            }
            closure(self.result)
        }
        return self
    }

    @discardableResult
    public func cancelled(_ closure: @escaping () -> Void) -> Self {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.cancelled else {
                return
            }
            closure()
        }
        return self
    }

    @discardableResult
    public func then<U>(_ lazy: LazyPoste<U>) -> Poste<U> {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.done else {
                return
            }
            lazy.fire()
        }
        return lazy
    }

    @discardableResult
    public func `else`<U>(_ lazy: LazyPoste<U>) -> Poste<U> {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard !self.done else {
                return
            }
            lazy.fire()
        }
        return lazy
    }

    @discardableResult
    public func then<U>(_ lazy: LazyThrowingPoste<U>) -> ThrowingPoste<U> {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.done else {
                return
            }
            lazy.fire()
        }
        return lazy
    }

    @discardableResult
    public func `else`<U>(_ lazy: LazyThrowingPoste<U>) -> ThrowingPoste<U> {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard !self.done else {
                return
            }
            lazy.fire()
        }
        return lazy
    }
}

public class ThrowingPoste<T> {

    internal let group = DispatchGroup()
    internal let qos: DispatchQoS

    internal private(set) var result: T!
    internal private(set) var error: Error?

    private var mainWorkItem: DispatchWorkItem!
    private var timeoutWorkItem: DispatchWorkItem!

    private var done = false
    private var cancelled = false
    private var thrown = false

    internal private(set) var isFired = false

    internal required init(closure: @escaping () throws -> T, qos: DispatchQoS, timeout: DispatchTimeInterval) {
        self.group.enter()
        self.qos = qos
        self.mainWorkItem = DispatchWorkItem(qos: self.qos) {
            do {
                self.result = try closure()
            }
            catch {
                self.error = error
            }
        }
        self.timeoutWorkItem = DispatchWorkItem(qos: self.qos) {
            if let time = DispatchTime(dispatchTimeIntervalSinceNow: timeout) {
                switch self.mainWorkItem.wait(timeout: time) {
                case .success:
                    if self.error == nil {
                        self.done = true
                    }
                    else {
                        self.thrown = true
                    }
                case .timedOut:
                    self.mainWorkItem.cancel()
                    if self.error == nil {
                        self.cancelled = true
                    }
                    else {
                        self.thrown = true
                    }
                }
            }
            else {
                self.mainWorkItem.wait()
                if self.error == nil {
                    self.done = true
                }
                else {
                    self.thrown = true
                }
            }
        }
        self.timeoutWorkItem.notify(qos: self.qos, queue: globalQueue) {
            self.group.leave()
        }
        self.fire()
    }

    internal func fire() {
        guard !self.isFired else {
            return
        }
        self.isFired = true
        globalQueue.async(group: self.group, execute: self.mainWorkItem)
        globalQueue.async(group: self.group, execute: self.timeoutWorkItem)
    }

    public func done(_ closure: @escaping (T) -> Void) -> Self {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.done else {
                return
            }
            closure(self.result)
        }
        return self
    }

    public func cancelled(_ closure: @escaping () -> Void) -> Self {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.cancelled else {
                return
            }
            closure()
        }
        return self
    }

    public func thrown(_ closure: @escaping (Error) -> Void) -> Self {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.thrown else {
                return
            }
            closure(self.error!)
        }
        return self
    }

    public func then<U>(_ lazy: LazyPoste<U>) -> Poste<U> {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.done else {
                return
            }
            lazy.fire()
        }
        return lazy
    }

    public func `else`<U>(_ lazy: LazyPoste<U>) -> Poste<U> {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard !self.done else {
                return
            }
            lazy.fire()
        }
        return lazy
    }

    public func then<U>(_ lazy: LazyThrowingPoste<U>) -> ThrowingPoste<U> {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.done else {
                return
            }
            lazy.fire()
        }
        return lazy
    }

    public func `else`<U>(_ lazy: LazyThrowingPoste<U>) -> ThrowingPoste<U> {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard !self.done else {
                return
            }
            lazy.fire()
        }
        return lazy
    }
}

extension ThrowingPoste
where T == Void {

    @discardableResult
    public func done(_ closure: @escaping (T) -> Void) -> Self {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.done else {
                return
            }
            closure(self.result)
        }
        return self
    }

    @discardableResult
    public func cancelled(_ closure: @escaping () -> Void) -> Self {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.cancelled else {
                return
            }
            closure()
        }
        return self
    }

    @discardableResult
    public func thrown(_ closure: @escaping (Error) -> Void) -> Self {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.thrown else {
                return
            }
            closure(self.error!)
        }
        return self
    }

    @discardableResult
    public func then<U>(_ lazy: LazyPoste<U>) -> Poste<U> {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.done else {
                return
            }
            lazy.fire()
        }
        return lazy
    }

    @discardableResult
    public func `else`<U>(_ lazy: LazyPoste<U>) -> Poste<U> {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard !self.done else {
                return
            }
            lazy.fire()
        }
        return lazy
    }

    @discardableResult
    public func then<U>(_ lazy: LazyThrowingPoste<U>) -> ThrowingPoste<U> {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.done else {
                return
            }
            lazy.fire()
        }
        return lazy
    }

    @discardableResult
    public func `else`<U>(_ lazy: LazyThrowingPoste<U>) -> ThrowingPoste<U> {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard !self.done else {
                return
            }
            lazy.fire()
        }
        return lazy
    }
}

public class LazyPoste<T>: Poste<T> {

    private var shouldFire = false

    internal override func fire() {
        guard self.shouldFire else {
            return self.shouldFire = true
        }
        super.fire()
    }
}

public class LazyThrowingPoste<T>: ThrowingPoste<T> {

    private var shouldFire = false

    internal override func fire() {
        guard self.shouldFire else {
            return self.shouldFire = true
        }
        super.fire()
    }
}
