// This file is automatically generated by GYB: Generate Your Boilerplate
// DO NOT EDIT

import Dispatch

internal let globalQueue =
    DispatchQueue(
        label: "moe.minacle.lib.poste",
        attributes: .concurrent)


public protocol PosteProtocol {
    associatedtype Result
}

public class Poste<Result>: PosteProtocol {

    internal let group = DispatchGroup()
    internal let qos: DispatchQoS

    internal fileprivate(set) var result: Result!

    fileprivate var mainWorkItem: DispatchWorkItem!
    fileprivate var timeoutWorkItem: DispatchWorkItem!

    internal fileprivate(set) var done = false
    fileprivate var cancelled = false

    internal private(set) var isFired = false

    internal required init(qos: DispatchQoS) {
        self.qos = qos
    }

    internal convenience init(closure: @escaping () -> Result, qos: DispatchQoS, timeout: DispatchTimeInterval) {
        self.init(qos: qos)

        self.group.enter()
        self.mainWorkItem = DispatchWorkItem(qos: self.qos) {
            self.result = closure()
        }
        self.timeoutWorkItem = DispatchWorkItem(qos: self.qos) {
            if let time = DispatchTime(dispatchTimeIntervalSinceNow: timeout) {
                switch self.mainWorkItem.wait(timeout: time) {
                case .success:
                    self.done = true
                case .timedOut:
                    self.mainWorkItem.cancel()
                    self.cancelled = true
                }
            }
            else {
                self.mainWorkItem.wait()
                self.done = true
            }
        }
        self.timeoutWorkItem.notify(qos: self.qos, queue: globalQueue) {
            self.group.leave()
        }
        self.fire()
    }

    internal func fire() {
        guard !self.isFired else {
            return
        }
        self.isFired = true
        globalQueue.async(group: self.group, execute: self.mainWorkItem)
        globalQueue.async(group: self.group, execute: self.timeoutWorkItem)
    }

    public func done(_ closure: @escaping (Result) -> Void) -> Self {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.done else {
                return
            }
            closure(self.result)
        }
        return self
    }

    public func cancelled(_ closure: @escaping () -> Void) -> Self {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.cancelled else {
                return
            }
            closure()
        }
        return self
    }

    public func then<T, U: Poste<T>>(_ lazy: LazyPoste<T, U>) -> U {
            globalQueue.async(qos: self.qos) {
                self.group.wait()
                guard self.done else {
                    return
                }
                lazy.fire()
            }
            return lazy.base
    }

    /* This will introduce SIL crash:
    public func then<T: Poste>(_ lazy: LazyPoste<T.Result, T>) -> T {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.done else {
                return
            }
            lazy.fire()
        }
        return lazy.base
    }
    */

    public func `else`<T, U: Poste<T>>(_ lazy: LazyPoste<T, U>) -> U {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard !self.done else {
                return
            }
            lazy.fire()
        }
        return lazy.base
    }
}

extension Poste where Result == Void {
    @discardableResult
    public func done(_ closure: @escaping (Result) -> Void) -> Self {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.done else {
                return
            }
            closure(self.result)
        }
        return self
    }

    @discardableResult
    public func cancelled(_ closure: @escaping () -> Void) -> Self {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.cancelled else {
                return
            }
            closure()
        }
        return self
    }

    @discardableResult
    public func then<T, U: Poste<T>>(_ lazy: LazyPoste<T, U>) -> U {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.done else {
                return
            }
            lazy.fire()
        }
        return lazy.base
    }

    @discardableResult
    public func `else`<T, U: Poste<T>>(_ lazy: LazyPoste<T, U>) -> U {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard !self.done else {
                return
            }
            lazy.fire()
        }
        return lazy.base
    }
}

public class ThrowingPoste<Result>: Poste<Result> {
    internal private(set) var error: Error?
    private var thrown = false

    internal convenience init(closure: @escaping () throws -> Result, qos: DispatchQoS, timeout: DispatchTimeInterval) {
        self.init(qos: qos)

        self.group.enter()
        self.mainWorkItem = DispatchWorkItem(qos: self.qos) {
            do {
                self.result = try closure()
            }
            catch {
                self.error = error
            }
        }
        self.timeoutWorkItem = DispatchWorkItem(qos: self.qos) {
            if let time = DispatchTime(dispatchTimeIntervalSinceNow: timeout) {
                switch self.mainWorkItem.wait(timeout: time) {
                case .success:
                    if self.error == nil {
                        self.done = true
                    }
                    else {
                        self.thrown = true
                    }
                case .timedOut:
                    self.mainWorkItem.cancel()
                    if self.error == nil {
                        self.cancelled = true
                    }
                    else {
                        self.thrown = true
                    }
                }
            }
            else {
                self.mainWorkItem.wait()
                if self.error == nil {
                    self.done = true
                }
                else {
                    self.thrown = true
                }
            }
        }
        self.timeoutWorkItem.notify(qos: self.qos, queue: globalQueue) {
            self.group.leave()
        }
        self.fire()
    }

    public func thrown(_ closure: @escaping (Error) -> Void) -> Self {
        globalQueue.async(qos: self.qos) {
            self.group.wait()
            guard self.thrown else {
                return
            }
            closure(self.error!)
        }
        return self
    }
}

public class LazyPoste<Result, Base: Poste<Result>>: PosteProtocol {
    internal var base: Base
    private var shouldFire = false

    internal init(base: Base) {
        self.base = base
    }

    internal func fire() {
        guard self.shouldFire else {
            return self.shouldFire = true
        }
        base.fire()
    }
}
