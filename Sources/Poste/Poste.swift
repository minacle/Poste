// This file is automatically generated by GYB: Generate Your Boilerplate
// DO NOT EDIT

import Dispatch

public enum PosteState {

    case suspended
    case running
    case done
    case cancelled
    case thrown
}

internal let globalQueue =
    DispatchQueue(
        label: "moe.minacle.lib.poste",
        attributes: .concurrent)

open class NullablePoste<T> {

    internal let group = DispatchGroup()
    internal let qos: DispatchQoS

    internal private(set) var result: T?

    private var mainWorkItem: DispatchWorkItem!
    private var timeoutWorkItem: DispatchWorkItem!

    private var doneClosures = [(T?) -> Void]()
    private var cancelledClosures = [() -> Void]()

    private var hasEverActivatedOnce = false

    private var _state = PosteState.suspended

    public var state: PosteState {
        return self._state
    }

    public required init(closure: @escaping () -> T?, qos: DispatchQoS, activate: Bool, timeout: DispatchTimeInterval) {
        self.group.enter()
        self.qos = qos
        self.mainWorkItem = DispatchWorkItem(qos: self.qos) {
            self.result = closure()
        }
        self.timeoutWorkItem = DispatchWorkItem(qos: self.qos) {
            if let time = DispatchTime(dispatchTimeIntervalSinceNow: timeout) {
                switch self.mainWorkItem.wait(timeout: time) {
                case .success:
                    self._state = .done
                case .timedOut:
                    self.mainWorkItem.cancel()
                    self._state = .cancelled
                }
            }
            else {
                self.mainWorkItem.wait()
                self._state = .done
            }
        }
        self.timeoutWorkItem.notify(qos: self.qos, queue: globalQueue) {
            self.group.leave()
        }
        self.group.notify(qos: self.qos, queue: globalQueue) {
            switch self.state {
            case .done:
                let closures = self.doneClosures
                for i in 0 ..< closures.count {
                    let closure = closures[i]
                    let result = self.result
                    globalQueue.sync {
                        let closure = closure
                        let result = result
                        globalQueue.async(qos: self.qos) {
                            closure(result)
                        }
                    }
                }
            case .cancelled:
                let closures = self.cancelledClosures
                for i in 0 ..< closures.count {
                    let closure = closures[i]
                    globalQueue.sync {
                        let closure = closure
                        globalQueue.async(qos: self.qos) {
                            closure()
                        }
                    }
                }
            default:
                fatalError()
            }
            self.mainWorkItem = nil
            self.timeoutWorkItem = nil
            self.doneClosures.removeAll()
            self.cancelledClosures.removeAll()
        }
        if activate {
            self.activate()
        }
    }

    private func activate() {
        guard !self.hasEverActivatedOnce
        else {
            fatalError("Cannot activate \(self): this poste is already activated.")
        }
        self.hasEverActivatedOnce = true
        self._state = .running
        globalQueue.async(group: self.group, execute: self.mainWorkItem)
        globalQueue.async(group: self.group, execute: self.timeoutWorkItem)
    }

    open func cancel() {
        guard
            case .suspended = self.state,
            case .running = self.state
        else {
            switch self.state {
            case .done:
                fatalError("cannot cancel \(self): this poste is already done.")
            case .cancelled:
                fatalError("cannot cancel \(self): this poste is already cancelled.")
            default:
                fatalError()
            }
        }
        self._state = .cancelled
        self.mainWorkItem.cancel()
    }

    open func resume() {
        guard self.hasEverActivatedOnce
        else {
            self.activate()
            return
        }
        guard case .suspended = self.state
        else {
            switch self.state {
            case .running:
                fatalError("cannot resume \(self): this poste is already running.")
            case .done:
                fatalError("cannot resume \(self): this poste is already done.")
            case .cancelled:
                fatalError("cannot resume \(self): this poste is already cancelled.")
            default:
                fatalError()
            }
        }
        self._state = .running
        self.group.resume()
    }

    open func suspend() {
        guard case .running = self.state
        else {
            switch self.state {
            case .suspended:
                fatalError("cannot suspend \(self): this poste is already suspended.")
            case .done:
                fatalError("cannot suspend \(self): this poste is already done.")
            case .cancelled:
                fatalError("cannot suspend \(self): this poste is already cancelled.")
            default:
                fatalError()
            }
        }
        self._state = .suspended
        self.group.suspend()
    }

    public func done(_ closure: @escaping (T?) -> Void) -> NullablePoste<T> {
        self.doneClosures.append(closure)
        return self
    }

    public func cancelled(_ closure: @escaping () -> Void) -> NullablePoste<T> {
        self.cancelledClosures.append(closure)
        return self
    }
}

open class NonnullPoste<T> {

    internal let group = DispatchGroup()
    internal let qos: DispatchQoS

    internal private(set) var result: T!

    private var mainWorkItem: DispatchWorkItem!
    private var timeoutWorkItem: DispatchWorkItem!

    private var doneClosures = [(T) -> Void]()
    private var cancelledClosures = [() -> Void]()

    private var hasEverActivatedOnce = false

    private var _state = PosteState.suspended

    public var state: PosteState {
        return self._state
    }

    public required init(closure: @escaping () -> T, qos: DispatchQoS, activate: Bool, timeout: DispatchTimeInterval) {
        self.group.enter()
        self.qos = qos
        self.mainWorkItem = DispatchWorkItem(qos: self.qos) {
            self.result = closure()
        }
        self.timeoutWorkItem = DispatchWorkItem(qos: self.qos) {
            if let time = DispatchTime(dispatchTimeIntervalSinceNow: timeout) {
                switch self.mainWorkItem.wait(timeout: time) {
                case .success:
                    self._state = .done
                case .timedOut:
                    self.mainWorkItem.cancel()
                    self._state = .cancelled
                }
            }
            else {
                self.mainWorkItem.wait()
                self._state = .done
            }
        }
        self.timeoutWorkItem.notify(qos: self.qos, queue: globalQueue) {
            self.group.leave()
        }
        self.group.notify(qos: self.qos, queue: globalQueue) {
            switch self.state {
            case .done:
                let closures = self.doneClosures
                for i in 0 ..< closures.count {
                    let closure = closures[i]
                    let result = self.result!
                    globalQueue.sync {
                        let closure = closure
                        let result = result
                        globalQueue.async(qos: self.qos) {
                            closure(result)
                        }
                    }
                }
            case .cancelled:
                let closures = self.cancelledClosures
                for i in 0 ..< closures.count {
                    let closure = closures[i]
                    globalQueue.sync {
                        let closure = closure
                        globalQueue.async(qos: self.qos) {
                            closure()
                        }
                    }
                }
            default:
                fatalError()
            }
            self.mainWorkItem = nil
            self.timeoutWorkItem = nil
            self.doneClosures.removeAll()
            self.cancelledClosures.removeAll()
        }
        if activate {
            self.activate()
        }
    }

    private func activate() {
        guard !self.hasEverActivatedOnce
        else {
            fatalError("Cannot activate \(self): this poste is already activated.")
        }
        self.hasEverActivatedOnce = true
        self._state = .running
        globalQueue.async(group: self.group, execute: self.mainWorkItem)
        globalQueue.async(group: self.group, execute: self.timeoutWorkItem)
    }

    open func cancel() {
        guard
            case .suspended = self.state,
            case .running = self.state
        else {
            switch self.state {
            case .done:
                fatalError("cannot cancel \(self): this poste is already done.")
            case .cancelled:
                fatalError("cannot cancel \(self): this poste is already cancelled.")
            default:
                fatalError()
            }
        }
        self._state = .cancelled
        self.mainWorkItem.cancel()
    }

    open func resume() {
        guard self.hasEverActivatedOnce
        else {
            self.activate()
            return
        }
        guard case .suspended = self.state
        else {
            switch self.state {
            case .running:
                fatalError("cannot resume \(self): this poste is already running.")
            case .done:
                fatalError("cannot resume \(self): this poste is already done.")
            case .cancelled:
                fatalError("cannot resume \(self): this poste is already cancelled.")
            default:
                fatalError()
            }
        }
        self._state = .running
        self.group.resume()
    }

    open func suspend() {
        guard case .running = self.state
        else {
            switch self.state {
            case .suspended:
                fatalError("cannot suspend \(self): this poste is already suspended.")
            case .done:
                fatalError("cannot suspend \(self): this poste is already done.")
            case .cancelled:
                fatalError("cannot suspend \(self): this poste is already cancelled.")
            default:
                fatalError()
            }
        }
        self._state = .suspended
        self.group.suspend()
    }

    public func done(_ closure: @escaping (T) -> Void) -> NonnullPoste<T> {
        self.doneClosures.append(closure)
        return self
    }

    public func cancelled(_ closure: @escaping () -> Void) -> NonnullPoste<T> {
        self.cancelledClosures.append(closure)
        return self
    }
}

open class VoidPoste {

    internal let group = DispatchGroup()
    internal let qos: DispatchQoS

    private var mainWorkItem: DispatchWorkItem!
    private var timeoutWorkItem: DispatchWorkItem!

    private var doneClosures = [() -> Void]()
    private var cancelledClosures = [() -> Void]()

    private var hasEverActivatedOnce = false

    private var _state = PosteState.suspended

    public var state: PosteState {
        return self._state
    }

    public required init(closure: @escaping () -> Void, qos: DispatchQoS, activate: Bool, timeout: DispatchTimeInterval) {
        self.group.enter()
        self.qos = qos
        self.mainWorkItem = DispatchWorkItem(qos: self.qos) {
            closure()
        }
        self.timeoutWorkItem = DispatchWorkItem(qos: self.qos) {
            if let time = DispatchTime(dispatchTimeIntervalSinceNow: timeout) {
                switch self.mainWorkItem.wait(timeout: time) {
                case .success:
                    self._state = .done
                case .timedOut:
                    self.mainWorkItem.cancel()
                    self._state = .cancelled
                }
            }
            else {
                self.mainWorkItem.wait()
                self._state = .done
            }
        }
        self.timeoutWorkItem.notify(qos: self.qos, queue: globalQueue) {
            self.group.leave()
        }
        self.group.notify(qos: self.qos, queue: globalQueue) {
            switch self.state {
            case .done:
                let closures = self.doneClosures
                for i in 0 ..< closures.count {
                    let closure = closures[i]
                    globalQueue.sync {
                        let closure = closure
                        globalQueue.async(qos: self.qos) {
                            closure()
                        }
                    }
                }
            case .cancelled:
                let closures = self.cancelledClosures
                for i in 0 ..< closures.count {
                    let closure = closures[i]
                    globalQueue.sync {
                        let closure = closure
                        globalQueue.async(qos: self.qos) {
                            closure()
                        }
                    }
                }
            default:
                fatalError()
            }
            self.mainWorkItem = nil
            self.timeoutWorkItem = nil
            self.doneClosures.removeAll()
            self.cancelledClosures.removeAll()
        }
        if activate {
            self.activate()
        }
    }

    private func activate() {
        guard !self.hasEverActivatedOnce
        else {
            fatalError("Cannot activate \(self): this poste is already activated.")
        }
        self.hasEverActivatedOnce = true
        self._state = .running
        globalQueue.async(group: self.group, execute: self.mainWorkItem)
        globalQueue.async(group: self.group, execute: self.timeoutWorkItem)
    }

    open func cancel() {
        guard
            case .suspended = self.state,
            case .running = self.state
        else {
            switch self.state {
            case .done:
                fatalError("cannot cancel \(self): this poste is already done.")
            case .cancelled:
                fatalError("cannot cancel \(self): this poste is already cancelled.")
            default:
                fatalError()
            }
        }
        self._state = .cancelled
        self.mainWorkItem.cancel()
    }

    open func resume() {
        guard self.hasEverActivatedOnce
        else {
            self.activate()
            return
        }
        guard case .suspended = self.state
        else {
            switch self.state {
            case .running:
                fatalError("cannot resume \(self): this poste is already running.")
            case .done:
                fatalError("cannot resume \(self): this poste is already done.")
            case .cancelled:
                fatalError("cannot resume \(self): this poste is already cancelled.")
            default:
                fatalError()
            }
        }
        self._state = .running
        self.group.resume()
    }

    open func suspend() {
        guard case .running = self.state
        else {
            switch self.state {
            case .suspended:
                fatalError("cannot suspend \(self): this poste is already suspended.")
            case .done:
                fatalError("cannot suspend \(self): this poste is already done.")
            case .cancelled:
                fatalError("cannot suspend \(self): this poste is already cancelled.")
            default:
                fatalError()
            }
        }
        self._state = .suspended
        self.group.suspend()
    }

    @discardableResult
    public func done(_ closure: @escaping () -> Void) -> VoidPoste {
        self.doneClosures.append(closure)
        return self
    }

    @discardableResult
    public func cancelled(_ closure: @escaping () -> Void) -> VoidPoste {
        self.cancelledClosures.append(closure)
        return self
    }
}

open class ThrowingNullablePoste<T> {

    internal let group = DispatchGroup()
    internal let qos: DispatchQoS

    internal private(set) var result: T?
    internal private(set) var error: Error?

    private var mainWorkItem: DispatchWorkItem!
    private var timeoutWorkItem: DispatchWorkItem!

    private var doneClosures = [(T?) -> Void]()
    private var cancelledClosures = [() -> Void]()
    private var thrownClosures = [(Error) -> Void]()

    private var hasEverActivatedOnce = false

    private var _state = PosteState.suspended

    public var state: PosteState {
        return self._state
    }

    public required init(closure: @escaping () throws -> T?, qos: DispatchQoS, activate: Bool, timeout: DispatchTimeInterval) {
        self.group.enter()
        self.qos = qos
        self.mainWorkItem = DispatchWorkItem(qos: self.qos) {
            do {
                self.result = try closure()
            }
            catch {
                self.error = error
            }
        }
        self.timeoutWorkItem = DispatchWorkItem(qos: self.qos) {
            if let time = DispatchTime(dispatchTimeIntervalSinceNow: timeout) {
                switch self.mainWorkItem.wait(timeout: time) {
                case .success:
                    if self.error == nil {
                        self._state = .done
                    }
                    else {
                        self._state = .thrown
                    }
                case .timedOut:
                    self.mainWorkItem.cancel()
                    if self.error == nil {
                        self._state = .cancelled
                    }
                    else {
                        self._state = .thrown
                    }
                }
            }
            else {
                self.mainWorkItem.wait()
                if self.error == nil {
                    self._state = .done
                }
                else {
                    self._state = .thrown
                }
            }
        }
        self.timeoutWorkItem.notify(qos: self.qos, queue: globalQueue) {
            self.group.leave()
        }
        self.group.notify(qos: self.qos, queue: globalQueue) {
            switch self.state {
            case .done:
                let closures = self.doneClosures
                for i in 0 ..< closures.count {
                    let closure = closures[i]
                    let result = self.result
                    globalQueue.sync {
                        let closure = closure
                        let result = result
                        globalQueue.async(qos: self.qos) {
                            closure(result)
                        }
                    }
                }
            case .cancelled:
                let closures = self.cancelledClosures
                for i in 0 ..< closures.count {
                    let closure = closures[i]
                    globalQueue.sync {
                        let closure = closure
                        globalQueue.async(qos: self.qos) {
                            closure()
                        }
                    }
                }
            case .thrown:
                let closures = self.thrownClosures
                for i in 0 ..< closures.count {
                    let closure = closures[i]
                    let error = self.error!
                    globalQueue.sync {
                        let closure = closure
                        let error = error
                        globalQueue.async(qos: self.qos) {
                            closure(error)
                        }
                    }
                }
            default:
                fatalError()
            }
            self.mainWorkItem = nil
            self.timeoutWorkItem = nil
            self.doneClosures.removeAll()
            self.cancelledClosures.removeAll()
            self.thrownClosures.removeAll()
        }
        if activate {
            self.activate()
        }
    }

    private func activate() {
        guard !self.hasEverActivatedOnce
        else {
            fatalError("Cannot activate \(self): this poste is already activated.")
        }
        self.hasEverActivatedOnce = true
        self._state = .running
        globalQueue.async(group: self.group, execute: self.mainWorkItem)
        globalQueue.async(group: self.group, execute: self.timeoutWorkItem)
    }

    open func cancel() {
        guard
            case .suspended = self.state,
            case .running = self.state
        else {
            switch self.state {
            case .done:
                fatalError("cannot cancel \(self): this poste is already done.")
            case .cancelled:
                fatalError("cannot cancel \(self): this poste is already cancelled.")
            case .thrown:
                fatalError("cannot cancel \(self): this poste is already thrown.")
            default:
                fatalError()
            }
        }
        self._state = .cancelled
        self.mainWorkItem.cancel()
    }

    open func resume() {
        guard self.hasEverActivatedOnce
        else {
            self.activate()
            return
        }
        guard case .suspended = self.state
        else {
            switch self.state {
            case .running:
                fatalError("cannot resume \(self): this poste is already running.")
            case .done:
                fatalError("cannot resume \(self): this poste is already done.")
            case .cancelled:
                fatalError("cannot resume \(self): this poste is already cancelled.")
            case .thrown:
                fatalError("cannot resume \(self): this poste is already thrown.")
            default:
                fatalError()
            }
        }
        self._state = .running
        self.group.resume()
    }

    open func suspend() {
        guard case .running = self.state
        else {
            switch self.state {
            case .suspended:
                fatalError("cannot suspend \(self): this poste is already suspended.")
            case .done:
                fatalError("cannot suspend \(self): this poste is already done.")
            case .cancelled:
                fatalError("cannot suspend \(self): this poste is already cancelled.")
            case .thrown:
                fatalError("cannot suspend \(self): this poste is already thrown.")
            default:
                fatalError()
            }
        }
        self._state = .suspended
        self.group.suspend()
    }

    public func done(_ closure: @escaping (T?) -> Void) -> ThrowingNullablePoste<T> {
        self.doneClosures.append(closure)
        return self
    }

    public func cancelled(_ closure: @escaping () -> Void) -> ThrowingNullablePoste<T> {
        self.cancelledClosures.append(closure)
        return self
    }

    public func thrown(_ closure: @escaping (Error) -> Void) -> ThrowingNullablePoste<T> {
        self.thrownClosures.append(closure)
        return self
    }
}

open class ThrowingNonnullPoste<T> {

    internal let group = DispatchGroup()
    internal let qos: DispatchQoS

    internal private(set) var result: T!
    internal private(set) var error: Error?

    private var mainWorkItem: DispatchWorkItem!
    private var timeoutWorkItem: DispatchWorkItem!

    private var doneClosures = [(T) -> Void]()
    private var cancelledClosures = [() -> Void]()
    private var thrownClosures = [(Error) -> Void]()

    private var hasEverActivatedOnce = false

    private var _state = PosteState.suspended

    public var state: PosteState {
        return self._state
    }

    public required init(closure: @escaping () throws -> T, qos: DispatchQoS, activate: Bool, timeout: DispatchTimeInterval) {
        self.group.enter()
        self.qos = qos
        self.mainWorkItem = DispatchWorkItem(qos: self.qos) {
            do {
                self.result = try closure()
            }
            catch {
                self.error = error
            }
        }
        self.timeoutWorkItem = DispatchWorkItem(qos: self.qos) {
            if let time = DispatchTime(dispatchTimeIntervalSinceNow: timeout) {
                switch self.mainWorkItem.wait(timeout: time) {
                case .success:
                    if self.error == nil {
                        self._state = .done
                    }
                    else {
                        self._state = .thrown
                    }
                case .timedOut:
                    self.mainWorkItem.cancel()
                    if self.error == nil {
                        self._state = .cancelled
                    }
                    else {
                        self._state = .thrown
                    }
                }
            }
            else {
                self.mainWorkItem.wait()
                if self.error == nil {
                    self._state = .done
                }
                else {
                    self._state = .thrown
                }
            }
        }
        self.timeoutWorkItem.notify(qos: self.qos, queue: globalQueue) {
            self.group.leave()
        }
        self.group.notify(qos: self.qos, queue: globalQueue) {
            switch self.state {
            case .done:
                let closures = self.doneClosures
                for i in 0 ..< closures.count {
                    let closure = closures[i]
                    let result = self.result!
                    globalQueue.sync {
                        let closure = closure
                        let result = result
                        globalQueue.async(qos: self.qos) {
                            closure(result)
                        }
                    }
                }
            case .cancelled:
                let closures = self.cancelledClosures
                for i in 0 ..< closures.count {
                    let closure = closures[i]
                    globalQueue.sync {
                        let closure = closure
                        globalQueue.async(qos: self.qos) {
                            closure()
                        }
                    }
                }
            case .thrown:
                let closures = self.thrownClosures
                for i in 0 ..< closures.count {
                    let closure = closures[i]
                    let error = self.error!
                    globalQueue.sync {
                        let closure = closure
                        let error = error
                        globalQueue.async(qos: self.qos) {
                            closure(error)
                        }
                    }
                }
            default:
                fatalError()
            }
            self.mainWorkItem = nil
            self.timeoutWorkItem = nil
            self.doneClosures.removeAll()
            self.cancelledClosures.removeAll()
            self.thrownClosures.removeAll()
        }
        if activate {
            self.activate()
        }
    }

    private func activate() {
        guard !self.hasEverActivatedOnce
        else {
            fatalError("Cannot activate \(self): this poste is already activated.")
        }
        self.hasEverActivatedOnce = true
        self._state = .running
        globalQueue.async(group: self.group, execute: self.mainWorkItem)
        globalQueue.async(group: self.group, execute: self.timeoutWorkItem)
    }

    open func cancel() {
        guard
            case .suspended = self.state,
            case .running = self.state
        else {
            switch self.state {
            case .done:
                fatalError("cannot cancel \(self): this poste is already done.")
            case .cancelled:
                fatalError("cannot cancel \(self): this poste is already cancelled.")
            case .thrown:
                fatalError("cannot cancel \(self): this poste is already thrown.")
            default:
                fatalError()
            }
        }
        self._state = .cancelled
        self.mainWorkItem.cancel()
    }

    open func resume() {
        guard self.hasEverActivatedOnce
        else {
            self.activate()
            return
        }
        guard case .suspended = self.state
        else {
            switch self.state {
            case .running:
                fatalError("cannot resume \(self): this poste is already running.")
            case .done:
                fatalError("cannot resume \(self): this poste is already done.")
            case .cancelled:
                fatalError("cannot resume \(self): this poste is already cancelled.")
            case .thrown:
                fatalError("cannot resume \(self): this poste is already thrown.")
            default:
                fatalError()
            }
        }
        self._state = .running
        self.group.resume()
    }

    open func suspend() {
        guard case .running = self.state
        else {
            switch self.state {
            case .suspended:
                fatalError("cannot suspend \(self): this poste is already suspended.")
            case .done:
                fatalError("cannot suspend \(self): this poste is already done.")
            case .cancelled:
                fatalError("cannot suspend \(self): this poste is already cancelled.")
            case .thrown:
                fatalError("cannot suspend \(self): this poste is already thrown.")
            default:
                fatalError()
            }
        }
        self._state = .suspended
        self.group.suspend()
    }

    public func done(_ closure: @escaping (T) -> Void) -> ThrowingNonnullPoste<T> {
        self.doneClosures.append(closure)
        return self
    }

    public func cancelled(_ closure: @escaping () -> Void) -> ThrowingNonnullPoste<T> {
        self.cancelledClosures.append(closure)
        return self
    }

    public func thrown(_ closure: @escaping (Error) -> Void) -> ThrowingNonnullPoste<T> {
        self.thrownClosures.append(closure)
        return self
    }
}

open class ThrowingVoidPoste {

    internal let group = DispatchGroup()
    internal let qos: DispatchQoS

    internal private(set) var error: Error?

    private var mainWorkItem: DispatchWorkItem!
    private var timeoutWorkItem: DispatchWorkItem!

    private var doneClosures = [() -> Void]()
    private var cancelledClosures = [() -> Void]()
    private var thrownClosures = [(Error) -> Void]()

    private var hasEverActivatedOnce = false

    private var _state = PosteState.suspended

    public var state: PosteState {
        return self._state
    }

    public required init(closure: @escaping () throws -> Void, qos: DispatchQoS, activate: Bool, timeout: DispatchTimeInterval) {
        self.group.enter()
        self.qos = qos
        self.mainWorkItem = DispatchWorkItem(qos: self.qos) {
            do {
                try closure()
            }
            catch {
                self.error = error
            }
        }
        self.timeoutWorkItem = DispatchWorkItem(qos: self.qos) {
            if let time = DispatchTime(dispatchTimeIntervalSinceNow: timeout) {
                switch self.mainWorkItem.wait(timeout: time) {
                case .success:
                    if self.error == nil {
                        self._state = .done
                    }
                    else {
                        self._state = .thrown
                    }
                case .timedOut:
                    self.mainWorkItem.cancel()
                    if self.error == nil {
                        self._state = .cancelled
                    }
                    else {
                        self._state = .thrown
                    }
                }
            }
            else {
                self.mainWorkItem.wait()
                if self.error == nil {
                    self._state = .done
                }
                else {
                    self._state = .thrown
                }
            }
        }
        self.timeoutWorkItem.notify(qos: self.qos, queue: globalQueue) {
            self.group.leave()
        }
        self.group.notify(qos: self.qos, queue: globalQueue) {
            switch self.state {
            case .done:
                let closures = self.doneClosures
                for i in 0 ..< closures.count {
                    let closure = closures[i]
                    globalQueue.sync {
                        let closure = closure
                        globalQueue.async(qos: self.qos) {
                            closure()
                        }
                    }
                }
            case .cancelled:
                let closures = self.cancelledClosures
                for i in 0 ..< closures.count {
                    let closure = closures[i]
                    globalQueue.sync {
                        let closure = closure
                        globalQueue.async(qos: self.qos) {
                            closure()
                        }
                    }
                }
            case .thrown:
                let closures = self.thrownClosures
                for i in 0 ..< closures.count {
                    let closure = closures[i]
                    let error = self.error!
                    globalQueue.sync {
                        let closure = closure
                        let error = error
                        globalQueue.async(qos: self.qos) {
                            closure(error)
                        }
                    }
                }
            default:
                fatalError()
            }
            self.mainWorkItem = nil
            self.timeoutWorkItem = nil
            self.doneClosures.removeAll()
            self.cancelledClosures.removeAll()
            self.thrownClosures.removeAll()
        }
        if activate {
            self.activate()
        }
    }

    private func activate() {
        guard !self.hasEverActivatedOnce
        else {
            fatalError("Cannot activate \(self): this poste is already activated.")
        }
        self.hasEverActivatedOnce = true
        self._state = .running
        globalQueue.async(group: self.group, execute: self.mainWorkItem)
        globalQueue.async(group: self.group, execute: self.timeoutWorkItem)
    }

    open func cancel() {
        guard
            case .suspended = self.state,
            case .running = self.state
        else {
            switch self.state {
            case .done:
                fatalError("cannot cancel \(self): this poste is already done.")
            case .cancelled:
                fatalError("cannot cancel \(self): this poste is already cancelled.")
            case .thrown:
                fatalError("cannot cancel \(self): this poste is already thrown.")
            default:
                fatalError()
            }
        }
        self._state = .cancelled
        self.mainWorkItem.cancel()
    }

    open func resume() {
        guard self.hasEverActivatedOnce
        else {
            self.activate()
            return
        }
        guard case .suspended = self.state
        else {
            switch self.state {
            case .running:
                fatalError("cannot resume \(self): this poste is already running.")
            case .done:
                fatalError("cannot resume \(self): this poste is already done.")
            case .cancelled:
                fatalError("cannot resume \(self): this poste is already cancelled.")
            case .thrown:
                fatalError("cannot resume \(self): this poste is already thrown.")
            default:
                fatalError()
            }
        }
        self._state = .running
        self.group.resume()
    }

    open func suspend() {
        guard case .running = self.state
        else {
            switch self.state {
            case .suspended:
                fatalError("cannot suspend \(self): this poste is already suspended.")
            case .done:
                fatalError("cannot suspend \(self): this poste is already done.")
            case .cancelled:
                fatalError("cannot suspend \(self): this poste is already cancelled.")
            case .thrown:
                fatalError("cannot suspend \(self): this poste is already thrown.")
            default:
                fatalError()
            }
        }
        self._state = .suspended
        self.group.suspend()
    }

    @discardableResult
    public func done(_ closure: @escaping () -> Void) -> ThrowingVoidPoste {
        self.doneClosures.append(closure)
        return self
    }

    @discardableResult
    public func cancelled(_ closure: @escaping () -> Void) -> ThrowingVoidPoste {
        self.cancelledClosures.append(closure)
        return self
    }

    @discardableResult
    public func thrown(_ closure: @escaping (Error) -> Void) -> ThrowingVoidPoste {
        self.thrownClosures.append(closure)
        return self
    }
}
